个人体会第二步

一，《这个程序员在阿里五年晋升三次，Coding 是立身之本》	https://blog.csdn.net/weixin_44326589/article/details/90437977

	1，让自己脱离舒适区：跟当时的主管说，我很焦虑，因为各种工作上的问题，想知道该怎么避免这种状态。
		一个刚毕业的小同学，应该还是埋头做事的阶段，如果有焦虑感，那是非常好的事情，一定要保持住
		我就记住了这句话，不再排斥自己因为能力不够，工作没做不到位带来的不适感，而是利用这些，督促自己学习、适应、解决问题，同时尽量让自己保持状态，脱离舒适区。
	2，皮实一点，帮团队承担更多
		帮团队承担更多就是让自己做到持续成长的方式，判断一件事要不要做的原因不是这件事做完是否可以拿出来讲，而是这件事是否可以解决团队的问题，因为解决问题的过程我一定可以学到东西，
		同时也会让我得到团队的认可，当然也附带了其他好处，比如事情做得多了，年终总结的时候，一定有值得总结沉淀的亮点，就像广撒网一样。
	3，向身边优秀的同学看齐
		大公司与创业公司该去哪里，在我看来，大公司优先级远超过创业公司的原因是，大公司平台好，聚集了行业内最顶尖的人才
		学到别人的思考，应用到自己的工作里。也因此养成了总结的习惯，长期培养的抽象总结能力

	关于晋升
		天时、地利、人和缺一不可的
		关于地利，我的经验是，在一个领域内不断地学习，是成长的必要条件。
		关于人和，对我帮助最大的方法是，永远按照更高的层级要求自己做事情。其实逻辑很简单，一定是一个连续的、循序渐进的过程。
				不管是做什么，一定要以更高的目标要求自己。

	总结：Coding 是立身之本
		最后这一条就是汇聚所有心得的基础。“我们要保持一直在一线 coding”（在一线编程）
		我认为作为主管第一要务是对团队负责，保证团队目标达成，保证团队稳定，负责团队每个人的成长
		持续 coding 可以保持一个人敏锐的技术嗅觉，在技术选型，方案讨论时做出正确的判断，避免自己逐渐演变成太“形而上”的技术思维。
		但从精力分配角度来看，对团队负责一定会占用大部分精力，我的经验是，多写，多 CR。
		（CR：code review 代码审查）

二，《Kotlin 和 Flutter 对于开发者究竟意味着什么？》
	笔者认为一个技术人员想要具备完善的素养，需要朝着这些方向努力：
	1，夯实基础；
	2，学好英语；
	3，提升学习能力；
	4，坚持总结归纳问题的习惯；
	5，增强分析问题，解决问题的能力。
	
	一个技术人员能够走多远，靠的不是会某种技术，而是完善以上高质量的素养。
	
三，《Java面试官：老兄，你真的确定double精度比float低吗？？？》
	在金融计算中，必须要使用BigDecimal，double和float都不适合。因为单单一个精度问题就能把人整晕了。
	计算机进行的是二进制运算，我们输入的十进制数字会先转换成二进制，进行运算后再转换为十进制输出。
	double和float提供了快速的运算，然而问题在于转换为二进制的时候，有些数字不能完全转换，只能无限接近于原本的值，这就导致了你看到的不正确的结果。’”	
	BigDecimal可以表示任意精度的小数，并对它们进行计算。但要小心使用 BigDecimal(double) 构造函数，因为它会在计算的过程中产生舍入误差。
	
	2.0 / 0 = ∞
	2 / 0 直接报错。
	
	int[] a = {1, 2, 3, 4}
	int[] b = {2, 4}
	int[] c = {1, 3}
	int[] d = {2}
	
	我大致演算了一下。说一下我的思路。d只能是2，b只能是4，a是1或者3，c是3或者1。
	遍历长数组，剔除长数组中含有的最短数组的元素。b中剔除d中的2还剩下4，a中剔除d中的2还剩下1、3、4，c中不含d中元素，所以不用剔除。
	剔除后b中还剩下一个4，d中是一个2。再次遍历剔除a中的4。最后a和c中只剩下1和3了，再分别剔除互异的数就行了。”

	出平常工作时自己认为最难的事情，选项大致有：”
	写各种文档
	与客户沟通
	预估工作量
	给变量命名
	
	最难的是，给变量命名，
	阿里巴巴Java开发手册中「强制」规定，方法名、参数名、成员变量、局部变量要统一使用lowerCamelCase风格，必须遵从驼峰形式。”
	最好，变量声明的地方要离第一次使用的地方近。否则的话，代码阅读起来会很困难，因为人眼睛接受的屏幕高度是有限的。
	
四，《二叉查找树与平衡二叉树》----未看	https://blog.csdn.net/qq_25940921/article/details/82183093

五：《非科班的java程序员该如何补充计算机基础知识，需要看哪些书？》----https://blog.csdn.net/learning__java/article/details/90377617
	第二个问题，数据库要建索引，btree和hash两种索引，区别是什么？各自应该用在什么场景。
	第三个问题，为什么用消息队列？
	什么叫解藕，什么叫内聚？生产者消费者又是什么意思？
	结论如下：
	1 计算机组成原理，计算机操作系统，计算机网络，数据库，数据结构，算法 这是六门基础课要学习
	2 你没时间系统的学习一遍，只能去找工作中很大可能用到的，先过一遍，有基础概念，以后遇到问题的时候，可以知道归属哪个领域。
		怎么知道什么内容是可能用到的，请自行搜索腾讯课堂修真院的洗髓换骨营，缩减到了10％的内容。
	3 对于没有用户量的系统而言，没有太多学习基础课程的必要，因为你不需要解决这些问题。但薪水和你能解决的问题是等价的，你愿意一直只做初级程序员么？
	4 编程思维在基础课程里都有锻炼，在工作中也更重要。

六：《人类激励理论》	马斯洛需求层次理论是人本主义科学的理论之一，马斯洛需求层次理论便出自《人的动机理论》
	马斯洛理论
	把需求分成
		1，生理需求（Physiological needs）：	人类个人的生理机能就无法正常运转。换而言之，人类的生命就会因此受到威胁。在这个意义上说，生理需要是推动人们行动最首要的动力。
			激励措施：增加工资、改善劳动条件、给予更多的业余时间和工间休息、提高福利待遇。
		2，安全需求（Safety needs）：			整个有机体是一个追求安全的机制，人的感受器官、效应器官、智能和其他能量主要是寻求安全的工具，
			激励措施：强调规章制度、职业保障、福利待遇，并保护员工不致失业，提供医疗保险、失业保险和退休福利、避免员工收到双重的指令而混乱。
		3，爱和归属感（Love and belonging）：	人人都希望得到相互的关系和照顾。感情上的需要比生理上的需要来的细致，
			激励措施：提供同事间社交往来机会，支持与赞许员工寻找及建立和谐温馨的人际关系，开展有组织的体育比赛和集体聚会。
		4，尊重（Esteem）：						人人都希望自己有稳定的社会地位，要求个人的能力和成就得到社会的承认。
			激励措施：公开奖励和表扬，强调工作任务的艰巨性以及成功所需要的高超技巧，颁发荣誉奖章、在公司刊物发表文章表扬、优秀员工光荣榜。
		5，自我实现（Self-actualization）：		自我实现的需要是最高层次的需要，是指实现个人理想、抱负，发挥个人的能力到最大程度，
			激励措施：设计工作时运用复杂情况的适应策略，给有特长的人委派特别任务，在设计工作和执行计划时为下级留有余地。
		6，在自我实现需求之后，还有自我超越需求（Self-Transcendence needs），超自我实现应用
		
		马斯洛陆续写出了《动机与人格》、《存在心理学探索》、《宗教、价值观和高峰体验》、《科学心理学》、《人性能达的境界》、
		《人的动机理论》等著作，
	
	
七：高效能人士的七个习惯

	前言
	第一章：积极主动
		1，要完成最渴望的目标，战胜最艰巨的挑战，你必须发觉并应用一些原则或者自然法则。
		感想：
			1，有些东西不是你想做就能做到的，这句话我的感想体现在抗拒诱惑上，我们身边的诱惑实在是太多了，周末双休我想
			好好学习的时候，经常会被诱惑到去打游戏，而且不止一次。我的解决办法是，直接去公司，不呆在家里。
			在公司我就能好好学习。
			2，有些原则或者是什么，真的会引领你走向成功，PDCA CDOC DOE等等，很多东西，都是人类的思想结晶。包括孔孟之道，都是人类的结晶。
			
		2，恐惧和不安全感，我现在就想得到，谴责和抱怨，绝望和无助，缺乏人生平衡，渴望理解，冲突和分歧，停滞不前
		思想：
			恐惧和不安全是每个人都有的。请直面
			我现在就想得到，我有很多东西都不可能直接得到，世界不是你的欲望构成的，在中国的社会，更多的是温水煮青蛙 + 快刀斩乱麻，双管齐下。
			谴责抱怨，绝望无助，，，请积极乐观的面对世界。活着才是最难的事情
			缺乏人生平衡：每个人自己是世界上最宝贵的财富，其他的一切都是不重要的，不要沉陷在一些鸡毛蒜皮的小事上，健康 家庭 品德很多都是最重要的。
				加班重要吗，公司只给你8小时 的工资，你为什么要工作那么久，下班后的所有时间都是你自己的，你知道吗。
				你应该把握时间，引领自己走向成功。
		
		3，谁也无法说服和改变他人，因为我们每个人都守着一扇只能从内开启的改变之门，不论动之以情或者是说之以理，我们都不能替别人开门
		思想：
			我希望你能够自己打开门看看，外面的世界是那么的精彩，漂亮的，美丽的，更加丰富多彩的。
			但是这些东西都需要钱，钱从哪里来，从你的能力来，能力高的钱就多了，
			钱能够解决95%的问题。
		4，教育孩子
		思想：
			多鼓励孩子，孩子需要鼓励。
			不要直接以自己的孩子和其他孩子攀比，不再比较
			不再呵护孩子，而是告诉他，父母不用保护你了，你可以自己去做事情。有信心，开始肯定自我的价值。
		5，思维定式 和思维转换的力量
		思想：
			文艺复兴带来的是技术吗？是什么呢
			我觉得带来的是新鲜的思想，思维定式是可怕的，同事告诉我的是我没有时间学习，好好工作就能成功
			
			这些我觉得就是思维定式，思维一定要转换啊。
			时间都是挤出来的，只有为自己工作，才能够走向成功。
		6，遵循原则
		思想：	
			有些原则是必须要遵守的，做人要诚信，等等。
		7，治标不治本
		思想:
			如果你的方法不能够根治你现在的问题，那么你的方法就是没用的，。
			如果你提出的方法，不能够让你一直学习，那么你的方法就是错误的，没有效果。
			你需要找到一个方法，让你能够向着你的目标持续发展，并且走向成功

八：https://showme.codes/ 翟志军

九：《难得的一次技术面——终得小米offer》---掘金 波波仔--https://juejin.im/post/5cf9ddb0e51d4510774a8829
	两年经历的概括，
		再谦卑的骨头里，也流淌着江河。——葛亮《北鸢》
	
	不要看轻一个人。每一个人都是傻逼，但是其实每一个人都不是傻逼。
	你的圈子，决定了你的思维。

十：《面试了 N 个候选人后，我总结出这份 Java 面试准备技巧！》————狸猫技术窝-掘金-https://juejin.im/post/5cfa21c45188254c4346771c
	
十一：《字节跳动、腾讯后台开发面经分享(2019.5)》————天澄-掘金-字节跳动、腾讯后台开发面经分享(2019.5)
	
十二：《活多人少，每个需求都紧急，多数项目延期，怎么破？》——翟志军——http://showme.codes/2019-03-01/software-engineering-tricky-problem/
	
	第1，把所有的工作内容（包括日常维护和新功能实现）列出来，
		同时，也要找到这些工作的交集（避免重复开发）。
		工作内容列出来后，确定它们的业务价值及优先级，并预估其开发难度。
		有些新功能是老板直接下发的，但是实现难度过高且业务价值又不高（团队及产品经理觉得），能和老板谈就和老板谈。
		这部分工作是我觉得最难的。这个工作的优先级一定要让老板看到。主要是避免老板中间随意的插入需求。
		当然，有时需要向现实妥协，但不是每次。同时也要让所有人达成共识，遵守这个优先级

	第2，是找出团队平时工作中最耗时的环节（瓶颈），想办法在这个环节上减少耗时（自动化或者别的办法）。
		一般来说，经常工作在这个耗时环节的人会知道如何优化它。

	第3，是慢慢让人可以流动，意思是人没办法调剂到其它项目，通常是因为他不了解其它项目（业务或者技术）。
		所以，在平时，就要注意将项目的“知识”尽可能准确地传递给更多人。当然，也可以定向的传递。
		具体操作方式要看团队平时的协作方式。最后，1，2，3步需要重复执行，同时1，2，3步也不是顺序的。
		笔者提出这样的解法并不是笔者猜的，而是有依据的。依据如下：
		1，人员不足只是表象，我们怎么知道是真的人员不足，还是没有真正发挥每个人的最大潜能呢？
			第2、3步是为了让每个人发挥最大的潜能。而工具方面，个人建议通过看板可视化人员的工作内容，来达到了解当前资源状态的目的。
		2，即使每个人的潜能都发挥到了极致，但是还是出现人员不足的情况啊。这就是第1步要解决的问题。
			这时，我们要学会舍弃。但是为什么老板就不会舍弃，老爱插入一些所谓的紧急需求呢？
			个人认为是因为老板不了解你当前的工作内容及其优先级。所以，这个优先级一定要和老板达成共识。

	我只要结果，不管过程的管理方式。

十三：《最好的礼物是一个真诚的建议》——翟志军——http://showme.codes/2018-12-11/to-be-broad-minded-toward-others/
	对待上等人直指人心，可打可骂，以真面目待他；
	对待中等人最多隐喻他，要讲分寸，他受不起打骂；
	对待下等人要面带微笑，双手合十，他很脆弱、装不下太多指责和训斥，他只配用世俗的礼节
	
	到底是谁的问题不重要， 严于律己，宽以待人对你的职业生涯会很有帮助。
	
十四：《阿里三面后的思考——企业应该如何留住员工》-翟志军-http://showme.codes/2018-06-24/alibaba-interview/
		
	给了别人想要的，你就会得到你想要的，——红雀
	留住员工，靠的不是“留”，而是“给”。当然，前提是这个人值得留。

	这个理论告诉我们如何满足一个人的不同层次的需求，
	在公司层面，如何操作呢？
	毕竟公司里会同时存在不同层次需求的人，而且同一个人不同时期的需求还可能千差万别。
	海纳百川，有容乃大。
	但是不可能路边随随便便就收纳，而是能帮助公司实现目标的人。
	这是海纳百川的前提。

	P.S. 公司文化并不是没有理论的发展，而是要根据公司的发展需要进行调整。
	我再次强调，上述想法的前提：
	不可能路边随随便便就收纳，而是能帮助公司实现目标的人。所以，要严进。
	
	小结：听说30到35岁是大多数人职场的转折点。我相信了。想清自己想要的，是做好职业规划的前提。
	
十五：《如何进行有效的指导，如何成功的分配任务》——翟志军——http://showme.codes/2018-02-19/secrets-of-great-management-1/
	本文主要来自：《门后的秘密——卓越管理的故事》
	
	1，如何进行有效的指导
		指导也是管理者工作内容的一部分，但它着重于提高技术水平和能力。
		指导是一种帮忙与被帮忙的关系，所以一定要确认对方想要得到你的帮忙。
	指导要基于PDCA，P：收集资料，分析，目标确认，计划实施。D：DO，C：Cheak，A，Action总结
	
	2，成功地分配任务
		明智地选择你的分配任务对象。这名员工应该想要承担更多的责任，并已经确认了自己的职业发展方向，
		这项工作正好适合他的职业发展方向。不要选择对这项工作不感兴趣的下属接受任务。
	
	什么样的成果才你能接受的。
	在软件行业，特别是互联网行业，很多管理者也不完全知道自己对某项工作的期待。
	这不重要，重要的是管理者应该将这一点表明给下属听
	
	明确表明不被允许的方法
	确定阶段性里程碑。当你做出分配工作的决定后，确保这一决定至少分为两部分：
	做出备选方案；选择其一。一定要表明哪一（些）部分是你分配下去的，
	如果在这两部分工作之间的某一点，你想进行检查，请明确地提出来。

十六：《如何充分“使用”研发团队新人》——翟志军——http://showme.codes/2018-01-15/new-fish/

十七：《吐槽：那些Java设计中不得不说的槽点》-王下七匹狼-https://juejin.im/post/5d1eaee86fb9a07ef161a1b1
	1，求长度各有千秋
		数组的长度
		string的长度
		集合的长度
		
	2，字符串的截取
		public String substring(int beginIndex, int endIndex) {
		  if (beginIndex < 0) {
			  。。 。。 。。
		  }
		  if (endIndex > count) {
			   。。 。。 。。
		  }
		  if (beginIndex > endIndex) {
			   。。 。。 。。
		  }
		  return ((beginIndex == 0) && (endIndex == count)) ? this :
		   new String(offset + beginIndex, endIndex - beginIndex, value);
		}
		当我们调用字符串 str 的 substring 得到字符串 subStr，其实这个操作，
		无非就是调整了一下 subStr 的 offset 和 count ，用到的内容还是 str 之前的 value 字符数组，
		并没有重新创建新的专属于 subStr 的内容字符数组。如果 subStr 的生命周期要长于 str 或者手动设置 str 为null，
		当垃圾回收进行后，str 被回收掉，subStr 没有回收掉，那么内存占用依旧存在，因为 subStr 持有 str 字符数组的引用。

十八：《高并发核心技术之 - 幂等性》-幂等性-https://juejin.im/post/5d1d6bbc5188250501476798
	1，幂等性就是指：一个幂等操作任其执行多次所产生的影响均与一次执行的影响相同
		幂等性问题经常会是由网络问题引起的，还有重复操作引起的。
	2，场景一：比如点赞功能，一个用户只能对同一片文章点赞一次，重复点赞提示已经点过赞了。
		public void like(Article article,User user) {
			//检查是否点过赞
			if (checkIsLike(article,user)) {
				//点过赞了
				throw new ApiException(CodeEnums.SYSTEM_ERR);
			}
			else {
				//保存点赞
				saveLike(article,user);
			}
		}
		看上去好像没有什么问题，保存点赞之前已经检查过是否点赞了，理论上同一个人不会对同一篇文章重复点赞。
		但实际不是这样的。因为网络请求不是排队进来的，而是一窝蜂涌进来的。
		某些时候，用户网络不好，可能很短的时间内点击了多次，由于网络传输问题，这些请求可能会同时来到我们的服务器。

		第一个请求 checkIsLike（） 返回 false ， 正在执行 saveLike() 操作，还没来的及提交事务
		第二个请求过来了 ，checkIsLike（） 返回 也是 false , 并去 执行了 saveLike() 操作

		这样子，就造成了一个用户同时对一篇文章进行了多次点赞操作。
		这就是典型的幂等性问题， 操作了一次和操作了两次结果不一样，因为你多点了一次赞，按照幂等性原则 不管你点击了多少次结果都一样，只点了一次赞。
		很多场景都是这样造成的，比如用户重复下单，重复评论，重复提交表单等。
		那怎么解决呢？
		假设网络的请求是排队进来的就不会出现这个问题了。
		于是我们可以改成这样：
		public synchronized void like(Article article,User user) {
			//检查是否点过赞
			if (checkIsLike(article,user)) {
				//点过赞了
			throw new ApiException(CodeEnums.SYSTEM_ERR);
			}
			else {
				//保存点赞
			saveLike(article,user);
			}
		}
		synchronized 同步锁 这样我们的请求就会乖乖的排队进来了。

		PS ：这样做是效率比较低的做法，不建议这么做，只是举例子，synchronized 也不适合分布式集群场景。
	
	3，解决幂等性问题方案
		1，synchronized 适合单机应用，不追求性能 ，不追求并发。
		2，分布式锁 但是往往我们的应用是分布式的集群，并且很讲究性能，并发，
			所以我们需要用到 分布式锁 来解决这个问题。	

十九：《工具类算法--快排的优化（Java）》-作者：defineYIDA-https://juejin.im/post/5d1c039d6fb9a07eb67daa82
	
	算法的运行时间耗费在：
	1）比较元素；
	2）移动元素。
	
	1，快速排序（quick sort）
		元素移动次数少，元素比较次数多；
	2，归并排序（merge sort）
		元素移到次数多，元素比较次数最少。
	如果移动次数比较少，就使用快排。
	如果比较次数比较少，就使用归排。
	
	快速排序的处理方式。
		从第一个排序方式开始。

二十：《你所不知道的HelloWorld背后的执行原理》-饭谈编程-
	整个代码的执行过程可以分为三个阶段：1，代码编译；2，类加载；3，类执行
	1，代码编译的作用就是将我们编写的 Main.java文件转化为Main.class文件，.class在这里又被称为字节码文件
		1，词法分析，即将源代码的字符流转变为Token集的过程
			比如整型int在我们编程中它就是三个字符组成的，就是i、n、t 三个字符，而在编译过程中它就是一个Token，不可拆分。
		2，语法分析，构建抽象语法树了，
			所谓的抽象语法树其实就是一种用来描述程序代码语法结构的树形表示方式，
			其中语法树的每一个节点都代表着程序代码中的一个语法结构，如包、类型、修饰符、运算符等。
		3，填充符号表
			符号表是由一组符号地址和符号信息构成的表格，
			这个表格在编译的不同阶段都会被用到，如在目标代码生成阶段，会对符号名进行地址分配，而符号表就是地址分配的依据。
		4，语义分析
			语义分析，也就是语义检测阶段。检测语法树是否合理，语义分析会通过标注检查和数据及控制流分析检查两步入手，在生成字节码的最后一步信息把关
		5，字节码生成，将前面各个步骤生成的信息转化成字节码然后放入磁盘中，还进行了少量的代码添加和转换工作，如我们自己重载的构造函数。
	
	2，类加载
		由类加载器将编译后的字节码文件【Main.class】加载到虚拟机中
		1，自定义加载器，使我们自己实现的
		2，启动类加载器 Bootstrap ClassLoader 
			启动类加载器的作用主要是加载 %JAVA_HOME%\jre\lib\rt.jar 类库，将其加载到虚拟机内存中
		3，扩展类加载器 Extension ClassLoader
			扩展类加载器的作用主要是负责加载JAVA_HOME\jre\lib\ext目录下的所有类库，主要是载入扩展包。
		4，系统类加载器 Application ClassLoader
			也称之为应用程序类加载器，负责加载用户类路径(也就是我们配置的CLASSPATH)上所指定的类库，是应用程序中默认的类加载。
		
		HelloWorld，就是系统类加载器 Application ClassLoader。
			先加载===>	验证
						||
						准备
						||
						解析==>初始化
			验证+准备+解析 称为链接阶段
			
		加载：由系统加载器，将编译后的.class文件加载到内存中，
			抛出个问题，所谓的加载到内存中，我们都知道JVM把内存分成了几大模块，那么请问是加载到哪个模块中？热点面试题，答案见文末！
		链接三部曲：将Main.class的二进制数据合并到JRE中
			验证阶段：对类加载器 传入的二进制数据流进行验证，避免危害虚拟机的安全
			准备阶段：正式为变量分配内存，并且设置类变量默认值，	private static String ii = "Hello World!";
				注意我描述的第一个是类变量，也就是static所描述的变量，其次是默认值，也就是上面的word的默认值null，如果是数字则为0。
			解析阶段：将常量池内的符号引用替换为直接引用的过程，
			初始化阶段：ii默认值是null，是系统赋的默认值，而在初始化阶段，则是根据我们人为的初始化类变量和其他资源，比如上面的ii则被我初始化成了"Hello World!"。
	
	3，类执行
		JVM
		Java虚拟机在运行的时候可以划分为三个子系统
		1，类加载子系统
		2，执行引擎子系统
		3，垃圾收集子系统
		
			1，类加载如上所示
			2，执行子系统就是类执行，也就是本系统
			执行引擎子系统会将字节码转换成机器码。字节码是被JVM识别的语言，机器码才是被操作系统识别的语言，
			字节码转换成机器码的过程，使用的就是JIT（Just In Time）即时编译器（对热代码整段编译），和Java字节码解释器（一行一行解释字节码）。
			JIT的编译流程：
				JVM字节码 -> 机器无关优化 -> 中间代码 -> 机器相关优化 -> 中间代码 -> 寄存器分配器 -> 中间代码 -> 目标机器码生成器 -> 目标机器码
			最后执行引擎会找到main()这个入口方法，并且执行其中的字节码指令。
	
	【思考】抛出个问题，所谓的加载到内存中，我们都知道JVM把内存分成了几大模块(见下)，那么请问是加载到哪个模块中？热点面试题，答案见文末！	
		【思考解惑】加载阶段完成后，虚拟机会将Main.class的二进制字节流按照虚拟机所需的格式存储在方法区中。
				然后在内存中实例化一个Java.lang.Class类的对象，作为程序访问方法区的类型数据的外部接口
				实例化后的java.lang。class类的对象也是存放在方法区的。
				
	【JVM的内存结构】JVM运行时的内存结构：堆，虚拟机栈，本地方法栈，方法区，程序计数器
		堆(Heap Memory)（线程共享）：存放所有的对象实例和数组，存放实例对象的地址，只存放对象本身
				堆的优势：在运行时，动态的分配内存大小。JAVA的垃圾回收器（GC）会自动的回收垃圾。
				缺点：在运行时动态的分配内存，存取速度较慢
				
				是VM管理的最大的一块内存，是GC主要的活动区域。由于现代的VM采用分代收集算法，因此java堆从GC的角度，可以细分为新生代(Eden区、From Survivor区和To Survivor区)
				和旧生代。等等，，，，，进一步的划分的目的是为了更好的回收内存和更快的分配内存，。
				
				
		虚拟机栈(Java Virtual Machine Stacks)：存放索引
		
				例：object obj = new object();
					object obj首先在栈中建立索引
					new object() 在堆中开辟内存地址
					然后在方法区中存放 类的元信息。
		方法区(Method Area)（线程共享）：用于存放加载类的元数据信息，如常量、静态变量和即时编译器编译后的代码。其中运行时常量池存放编译生成的各种常量。
				他是每一个类或接口的常量池的运行时的表现形式，类和接口被加载到JVM后对应的常量池就会被创建出来。
				
				HotSpot VM把GC分代收集扩展至方法区，HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器
				
				
		本地方法栈(Native Method Stacks)：	虚拟机栈是为虚拟机执行java方法服务的。本地方法栈是为虚拟机执行native方法而服务的。
				任何本地方法接口都会使用某种本地方法栈。
				而虚拟机调用java方法时，虚拟机会创建一个栈帧并且压入虚拟机栈；
				当虚拟机调用本地方法时（native），虚拟机不会创建新的栈帧，虚拟机会保持不变。虚拟机只是单纯的动态链接并直接调用相关的本地方法，
				
		程序计数器：指向当前线程正在执行的字节码指令的地址、行号。说明了当前线程正在执行的字节码
				为什么要存储他的地址和行号呢？CPU的工作原理是有任务调度的，有可能字节码没有执行完毕就被挂起。
	
	
二十一：《深入理解Java虚拟机(二)——new一个对象的创建》-天天向上酱-https://juejin.im/post/5d1dde3a518825608e7e529e
	1，对象的创建  new一个
		1，检查准备创建的对象类是否被加载，若没有，先加载此类；若加载完毕，进行下一步
		2，为新生的对象分配空间，对象类加载后，对象所需的空间是确定的，分配空间就是在内存中划分出一小块空间给对象。
			分配的方式有两种：
			1，指针的碰撞：我们使用的垃圾收集算法会导致已被使用的内存在一边，空闲的内存在另一边（复制算法，标记-整理算法）。
				可以通过一个指针往空闲内存方向移动一定的距离，即可以实现为新生的对象分配内存。
			2，空闲列表：我们使用的垃圾收集算法会导致 已使用的内存和空闲的内存相互交错时(标志-清除算法)。
				虚拟机会把空闲的内存地址和大小记录在空闲列表里面，在需要分配内存时，通过空闲列表查找到空闲内存进行分配
		3，将对象新分配到的空间初始化为零值，保证对象不赋初值就可以直接使用。
		4，设置对象头的信息
		5，从虚拟机的角度来看，对象已经生成。从JAVA的角度来看，对象的创建才刚刚开始。对象的构造函数还未被使用。
			
二十二：《连引用都答不上，凭什么说你是Java服务端开发》-饭谈编程 - https://mp.weixin.qq.com/s?__biz=MzI4NjMwMzgzOA==&mid=2247483776&idx=1&sn=f63daa22737da8d83727da0b437e2a51&scene=19#wechat_redirect
	1，JAva中的对象引用（ObjectReference）
		1，FinalReference强引用
		2，softReference软引用
		3，WeakReference弱引用
		4，PhantomReference虚引用
		这些引用都是为了：1，方便Jvm进行垃圾回收，2，方便开发人员进行使用，开发人员可以灵活的决定某些对象的生命周期
		
	2，FinalReference强引用
		类似 FF ff = new FF();这种的强引用，创建一个对象后，该引用会被保存在JVM栈里面，只要强引用存在，垃圾回收器就不会回收。
		我们经常会new一个对象的，new出来的就是强引用，只要引用存在就不会回收。
		1，JVM如何判断是否可以回收呢：：JVM的可达性分析算法。通过一系列的GC Root作为出发点，向下搜索，搜索过的路径为引用链。
			当一个对象到GC Root没有任何引用，就会被回收。
		2，哪些对象可以被回收呢？
			虚拟机栈中的引用的对象：就是栈中的对象的引用变量，（引用对象就是 堆中的数组或者对象的名称，这个名称也就是引用变量）
			方法区中类静态属性引用的对象
			方法区中常量引用的对象
			本地方法栈JNI引用的对象
			
二十三：《24小时学JavA》-XXXX - 
	0，== 和 equals
		1，==就是用来比较值是否相等
			int n=3;
			int m=3;
			
			System.out.println(n==m);
			
			String str = new String("hello");
			String str1 = new String("hello");
			String str2 = new String("hello");
			
			System.out.println(str1==str2);
			
			str1 = str;
			str2 = str;
			System.out.println(str1==str2);
			
			true
			false
			true
		
	
	1，继承：把多个类的内容定义到一个类中：class SonClass extends FuClass {}
		public class Animal {
			public int xx = 10;
			public void MakeNoise(){
				System.out.println("Animal + MakeNoise");
			}
			public void Eat(){
				System.out.println("Animal + Eat");
			}
			public void Sleep(){
				System.out.println("Animal + Sleep");
			}
			public void Roma(){
				System.out.println("Animal + Roma");
			}


			public static void main(String[] args) {
				Wolf wol = new Wolf();
				Animal ani = new Animal();
				wol.Roma();//Animal + Roma
				System.out.println(wol.xx);//20
				//System.out.println(xx);//当没有实例化Animal，则报错
				System.out.println(ani.xx);//10
			}
		}
		class Canine extends Animal{
			public void Roma(){
				System.out.println("Canine + Roma");
			}

		}
		class Wolf extends Animal{
			public void MakeNoise(){
				System.out.println("Wolf + MakeNoise");
			}
			public void Eat(){
				System.out.println("Wolf + Eat");
			}
			public int xx = 20;
		}


		/**
		 * Wolf w = new Wolf() ;
		 * w.MakeNoise ---- Wolf.MakeNoise
		 * w.roma ----- Canine.roma
		 * w.eat ----- Wolf.Eat
		 * w.sleep ----- Animal.sleep
		* */
		public 会被继承，，private不会被继承
		1，子类会继承父类所有的public类型的实例变量和方法，但不会继承父类所有的private的变量（int x）
		2，继承下来的方法可以被覆盖。（只会寻找到最近的方法，就近原则 ， 但是实例化的对象不可以被覆盖）
		3，
		
		继承的使用：
			提取出一组类间公共的，重复的代码，放在父类。这样一来，加入你有共同的部分要修改，就只有一个地方需要修改，且这样的改变，会应用到所有继承此行为的类
			所有扩充过他的类都会自动使用到新的版本。
			一般继承在2-3层
			可以用private 和 final描述类或者方法，，就可以防止被继承修改
	3，多态：同一个对象在不同时期表现的多种形态。
		编译时期状态和运行时期状态不一致的现象		
		System.out.println();
        Animal AniWol = new Wolf();
        System.out.println(AniWol.xx);
        AniWol.Eat();
        AniWol.MakeNoise();
        AniWol.Roma();
        AniWol.Sleep();
		//接上面的继承
		10
		Wolf + Eat
		Wolf + MakeNoise
		Animal + Roma
		Animal + Sleep
		
		1，参数必须一样，且返回类型必须兼容。
			父类的合约定义其他的程序代码要如何来使用方法。不管父类使用了哪种参数，覆盖此类方法的子类也一定要使用相同的参数。
			而不管父类返回的类型是什么，子类必须要声明返回一样的类型，或者该类型的子类。
			子类的对象必须得保证能够执行父类的一切。、
		2，不能降低方法的存取权限，
			存取权限必须相同，或者更为开放，、
			举例：你不能将一个公有的方法标记为私有。父类public子类 private
		2019年7月7日13:47:52
		
		调用object的多态，会将放进去的所有东西，出去的时候全部会变成object,
		可以使用强行转换，例如（Dog）o，，，当然可以使用instanceof来检查。
		如果类型转换错误，就会报错。所以需要先检查，
	
	3，方法的重载
		重载就是构造函数
		public class OverLoad{
			String uniqueID;
			public int AddNum(int a,int b){
				return a+b;
			}
			//输入两个int 就会报错
			public double AddNum(double a,double b){
				return a+b;
			}
			public void setUniquqeID(String TheID){
				uniqueID=TheID;
			}
			public void setUniquqeID(int ssNumber){
				String numString = "" + ssNumber;
				setUniquqeID(numString);
			}
		}
		1，返回类型可以不同，你可以任意的改变返回类型。但是不能覆盖使用不同的参数
		2，不能只改变返回类型，返回类型相同，参数一样，这是不被允许的。 
			就算是重载，也要让返回类型是父类版返回类型的子类
		重载的条件是使用不同的参数，返回类型是可以自由的定义的。
		3，你可以自由的更改存取权限，。
	
	4，抽象 - - - 阻止类被初始化，限制只有子类才可以被初始化。
		让这个类不能够被new出去初始化，。通过标记这个类为抽象的，让这个类不能创建任何类型的实例。
		abstract public class Animal {
		编译器不会让你初始化抽象类的，也不会让你实例化抽象类。
		2019年7月7日14:57:34
		不是抽象类就被称为具体类。抽象的类代表此类必须要被 extend过，抽象的方法代表此方法一定要被覆盖过。
		
		1，如果你声明出一个抽象的方法，就必须也将此类标记为抽象的。你不能在非抽象类中拥有抽象的方法。
			就算只有一个抽象的方法，此类也必须被标记为抽象的。
		2，抽象的方法没有实体。
	
		为什么要有抽象的方法？
			1，将可以继承的方法放在父类中，供子类继承
			2，如果有的时候无法给出任何子类都有意义的代码，那就定义出一组子型共同的协议
		这样做的好处是什么？
			多态。多态的好处就是所有的子型都会有哪些抽象的方法。
			你想达成的目标就是，使用父型作为方法的参数，返回类型或数组的类型。
			
	5，方法重写
	(1)子类中出现了和父类中方法声明一模一样的方法。
		复写，覆盖。
	(2)注意事项：
		A:子类方法的权限不能低于父类方法的权限
		B:父类私有的不能被重写
		C:静态只能重写静态
		
	2，final
		被他修饰的类具有以下要求：
			1，修饰的类不可以被继承；2，修饰的变量是常量；3，修饰的方法不可以被重写
		修饰方法的形式参数：
			修饰基本类型：基本类型的值不可以发生改变。
			修饰的引用类型：引用类型的地址不可以发生改变，但是内容可以改变，。
			
二十四：《JVM内存模型的相关概念》-qq_39558626 - https://bbs.csdn.net/topics/392214343?list=lz
	1，线程私有区
		1，程序计数器：当同时进行的线程数超过CPU数或者其内核数，就要通过时间片轮询分派CPU的时间资料，不免发生线程的切换。
				每一个线程都需要一个属于自己的计数器来记录下一条要运行的指令。
				如果是JAVA方法，则记录执行的字节码地址和行号，若是本地方法，则计数器清空。
		2，虚拟机栈：与线程同时创建。
				新调用的方法入栈，返回的出栈。
		3，本地方法栈
	
	2，线程共享区
		1，方法区
		2，堆
		
	3，垃圾回收
		1，回收的判断
			1，持有的判断：
				1，最先使用的是引用计数算法。当对象有一个引用，即增加一个计数。删除一个引用，即减少一个应用。计数为零的对象，判断为不可用。
					但是无法处理循环引用的问题。
				2，现在主流的是可达性分析方法：以GC Roots的对象作为起点，开始向下搜索。走过的路径是引用链，若所有的GC Roots都与某对象无引用链相连，即不可达，判断不可用。
			注意：GC Roots对象包括：虚拟机栈（栈帧）中的引用对象，方法区中的类静态属性引用对象，方法区中常量池引用的对象。本地方法栈JNI引用的对象。
			2，必要的判断：
				1，当对象没有重写finalize()方法或者finalize（）已被虚拟机调用过，都将被视为没有必要执行
					否则，此对象将放置在F-Queue的队列中，由一个虚拟机自动建立的、低优先级的Finalizer线程去触发该方法，但不承诺等待他运行结束。
					以防止执行缓慢或者死循环，导致其他队列永久等待，导致系统内存回收，系统崩溃。
				2，对F-Queue中的对象进行二次标记，只要有对象重新与GC-Roots对象关联，就会被移出队列，否则GC回收
		2，垃圾回收算法
			1，标记-
				https://bbs.csdn.net/topics/392214343?list=lz
		
				
	4，	

二十五：《剑指offer 第二版》
	1，全书目录：
		第一章：介绍面试的流程
		第二章：梳理应聘者在接受技术面试时需要用到的基础知识。主要是编程语言，数据结构及算法。
		第三章：讨论应聘者在面试时写出高质量代码的3个要点：
				期待应聘者写出的代码能够完成基本的功能,还能应对特殊情况并对非法输入进行合理的处理
				读完这一章,读者将学会如何从规范性、完整性和鲁棒性3个方面提高代码的质量
		第四章：总结在编程面试中解决难题的常用思路。遇到复杂的难题,那么应聘者最好在写代码之前形成清晰的思路。
				将学会如何用画图、举例和分解这3种思路来解决问题。
		第五章：如何优化代码的时间效率和空间效率。面试官总是期待应聘者能找到最优的解法。将学会优化时间效率及用空间换时间的常用算法
		第六章：总结面试中的各项能力。在面试过程中,面试官会一直关注应聘者的学习能力和沟通能力。
				除此之外,有些面试官还喜欢考查应聘者的知识迁移能力、抽象建模能力和发散思维能力。
		第七章：两个面试案例
				读者将看到应聘者在面试过程中的哪些举动是不好的行为,而哪些表现又是面试官所期待的行为。考察综合素质
		
	2，第一章 面试的流程
		2.1 对于初级程序员,我一般会偏向考查算法和数据结构,看应聘者的基本功;
			对于高级程序员,我会多关注专业技能和项目经验。”
			—何幸杰
			应聘者要事先做好准备,对公司近况、项目情况有所了解,对所应聘的工作很有热情。另外,应聘者还要准备好合适的问题问面试官。”
			—韩伟东
			应聘者在面试过程中首先需要放松,不要过于紧张,这有助于后面解决问题时开拓思路。其次不要急于编写代码,应该先了解清楚所要解决的问题。
			这时候最妤先和面试官多做沟通,然后开始做一些整体的设计和规划,这有助于编写高质量和高可读性的代码。
			写完代码后不要马上提交,最好自己检查并借助一些测试用例来测试几遍代码,找出可能出现的错误。”
			—尧敏
			¨神马’都是浮云,应聘技术岗位就是要踏实写程序。”
			-田超
		2.2 
		2.3 行为面试阶段
			1，面试开始的5~10分钟通常是行为面试的时间。在行为面试这个环节里,面试官会注意应聘者的性格特点,深入地了解简历中列举的项目经历。
			2，应聘者在准备简历的时候,建议用如图1.3所示的STAR模型描述自己经历过的每一个项目。
				Situation:简短的项目背景。比如项目的规模，开发的软件的功能，目标用户等。
					
				Task:自己完成的任务。这个要写详细，要让面试官对自己的工作目了然。在用词上要注意区分“参与”和“负责”:
					如果只是加入某一个开发团队写了几行代码就用“负责”,那就很危险。
					面试官看到简历上应聘者“负责”了某个项目,他可能就会问项目的总体框架设计、核心算法、团队合作等问题。
					这些问题对于只是简单“参与”的人来说,是很难回答的,会让面试官认为你不诚实,印象分会减去很多。
				Action:为完成任务自己做了哪些工作,是怎么做的。
						这里可以详细介绍。做系统设计的,可以介绍系统架构的特点;
						做软件开发的,可以写基于什么工具在哪个平台下应用了哪些技术;
						做软件测试的,可以写是手工测试还是自动化测试、是白盒测试还是黑盒测试等。
				Result:自己的贡献。
						这方面的信息可以写得具体些,最好能用数字加以说明。
						如果是参与功能开发,则可以说按时完成了多少功能:
						如果说做优化，则可以说性能提高的百分比是多少。
						如果说是维护，则可以说修改了多少个BUG。
				
				在介绍项目经验(包括在简历上介绍和面试时口头介绍)时,应聘者不必详述项目的背景,而要突出介绍自己完成的工作及取得的成绩。
				
				如果在应聘者的简历中上述4类信息还不够清晰,则面试官可能会追问相关的问题。除此之外,面试官针对项目经验最常问的问题包括如下几个类型:
				1，你在该项目中碰到的最大问题是什么,你是怎么解决的?
				2，从这个项目中你学到了什么?
				3，什么时候会和其他团队成员(包括开发人员、测试人员、设计人员、,项目经理等)有什么样的冲突,你们是怎么解决冲突的?
				
				应聘者在准备简历的时候,针对每一个项目经历都应提前做好相应的准备。只有准备充分,应聘者在行为面试环节才可以表现得游刃有余。
			
			3，应聘者掌握的技能除应聘者参与过的项目之外,面试官对应聘者掌握的技能也很感兴趣。他有可能针对简历上提到的技能提出问题。和描述项目时要注意“参与”
				和“负责”一样,描述技能掌握程度时也要注意“了解”、“熟悉”和“精通”的区别。“了解”指对某项技术只是上过课或者看过书,但没有做过实际的项目。
				通常不建议在简历中列出只是肤浅地了解一点的技能,除非这项技术应聘的职位的确需要。比如某学生读本科的时候学过《计算机图形学》这门课，但是没有项目经验。
			
			1，应聘者在面试之前需要做足准备,对编程语言、数据结构和算法等基础知识有全面的了解。
				2，面试的时候如果遇到简单的问题,则应聘者一定,要注重细节,写出完整、鲁棒的代码。
				3，如果遇到复杂的问题,则应聘者可以通过画图、举具体例子分析和分解复杂问题等方法先厘清思路再动手编程
				4，除此之外,应聘者还应该不断优化时间效率和空间效率,力求找到最优的解法。
				5，在面试过程中,应聘者还应该主动提问,以弄清楚题目的要求,表现自己的沟通能力。
				6，当面试官前后问的两个问题有相关性的时候,尽量把解决前面问题的思路迁移到后面的问题中去,展示自己良好的学习能力。
			
			2，高质量的代码
				只有注重质量的程序员,才能写出鲁棒、稳定的大型软件。
				在面试过程中,面试官总会格外关注边界条件、特殊输入等看似细枝末节但实则至关重要的地方,以考查应聘者是否注重代码质量。
			面试小提示
				面试官除了希望应聘者的代码能够完成基本的功能,还会关注应聘者是否考虑了边界条件、特殊输入(如 nullptr指针、空字符串等)及错误处理。
			
			3，清晰的思路
				只有思路清晰,应聘者才有可能在面试过程中解决复杂的问题。
				有时候面试官会有意出一些比较复杂的问题,以考查应聘者能否在短时间内形成清晰的思路并解决问题。

				首先,举几个简单的具体例子让自己理解问题。当我们一眼看不出问题中隐藏的规律的时候,
				可以试着用一两个具体的例子模拟操作的过程,这样说不定就能通过具体的例子找到抽象的规律。
				
				其次,可以试着用图形表示抽象的数据结构。
				像分析与链表、二叉树相关的题目,我们都可以画出它们的结构来简化题目。
				最后,可以试着把复杂的问题分解成若干简单的子问题,再解决。
				很多基于递归的思路,包括分治法和动态规划,都是把复杂的问题分解成一个或者多个简单的子问题。
				
				面试小提示：如果在面试的时候遇到难题,我们有3种办法分析、解决复杂的问题
							画图能使抽象问题形象化,举例使抽象问题具体化,分解使复杂问题简单化。

			4，优化效率问题
				
			5，优秀的综合能力
				沟通能力和学习能力
				IT行业知识更新很快,因此程序员只有具备很好的学习能力才能跟上知识更替的步伐。
				通常面试官有两种办法考查应聘者的学习能力。
				第一种方法是询问应聘者最近在看什么书、从中学到了哪些新技术。面试官可以用这个问题了解应聘者的学习愿望和学习能力。
				第二种方法是抛出一个新概念,接下来他会观察应聘者能不能在较短的时间内理解这个新概念并解决相关的问题。
						比如面试官要求应聘者计算第1500个丑数。很多人都没有听说过丑数这个概念。
						这时候面试官就会观察应聘者面对丑数这个新概念时,能不能经过提问、思考、再提问的过程,最终找出丑数的规律,
						从而找到解决方案(详见面试题49“丑数”)。
				知识迁移能力是一种特殊的学习能力。如果我们能够把已经掌握的知识迁移到其他领域,那么学习新技术或者解决新问题就会变得容易。
				面试官经常会先问一个简单的问题,再问一个很复杂但和前面的简单问题相关的问题。
				这时候面试官期待应聘者能够从简单问题中得到启示,从而找到解决复杂问题的窍门。
				比如面试官先要求应聘者写一个函数求斐波那契数
		
		2.4	应聘者提问环节	
			最后,推荐问的问题是与应聘的职位或者项目相关的问题。
			如果这种类型的问题问得很到位,那么面试官就会觉得你对应聘的职位很有兴趣不过要问好这种类型的问题也不容易,
			因为首先要对应聘的职位或者项目的背景有一定的了解。
			我们可以从两方面去了解相关的信息:
				一是面试前做足功课,到网上去搜集一些相关的信息,做到对公司成立时间、主要业务、职位要求等都了然于胸;
				二是面试过程中留心面试官说过的话。
			
			有不少面试官在面试之前会简单介绍与招聘职位相关的项目,其中会包含从其他渠道无法得到的信息,比如项目进展情况等。
			应聘者可以从中找出一两个点,然后向面试官提问。
	
	3.1 面试官谈基础知识
		3.1.1 基础知识反映了一个人的基本能力和基础素质,是以后工作中最核心的能力要求。我一般考查:
				(1)数据结构和算法;(2)编程能力;(3)部分数学知识,如概率;(4)问题的分析和推理能力。”
				—张晓禹(百度,技术经理)
			
			(1)编程基本功(特别喜欢字符串处理这一类的问题);(2)并发控制;(3)算法、复杂度;(4)语言的基本概念。”
				-张珺(百度,高级软件工程师)
				
				我会考查编程基础、计算机系统基础知识、算法及设计能力。
				这些是成为一个软件工程师的最基本的要求,这些方面表现出色的人,我们一般认为是有发展潜力的。”
				—韩伟东(盛大,高级研究员)
	3.2 数据结构
		
		74页